深入理解指针

指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。   要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的   类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。让我们分别说明。  　　先声明几个指针放着做例子：  　　例一：  　　(1)int*ptr;  　　(2)char*ptr;  　　(3)int**ptr;  　　(4)int(*ptr)[3];  　　(5)int*(*ptr)[4];  　　　　指针的类型　　从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：  　　(1)int*ptr;//指针的类型是int*  　　(2)char*ptr;//指针的类型是char*  　　(3)int**ptr;//指针的类型是int**  　　(4)int(*ptr)[3];//指针的类型是int(*)[3]  　　(5)int*(*ptr)[4];//指针的类型是int*(*)[4]  　　怎么样？找出指针的类型的方法是不是很简单？  　　指针所指向的类型　　当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。  　　从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：  　　(1)int*ptr;//指针所指向的类型是int  　　(2)char*ptr;//指针所指向的的类型是char  　　(3)int**ptr;//指针所指向的的类型是int*  　　(4)int(*ptr)[3];//指针所指向的的类型是int()[3]  　　(5)int*(*ptr)[4];//指针所指向的的类型是int*()[4]  　　在指针的算术运算中，指针所指向的类型有很大的作用。  　　指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C越来越熟悉时，你会发现，把与指针搅和在一起的 "类型 "这个概念分成 "指针的类型 "和 "指针所指向的类型 "两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。指针的值，或者叫指针所指向的内存区或地址　　指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。   指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为si   zeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。  　　指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。  　　以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？  　　指针本身所占据的内存区　　指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。  　　指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。  　　指针的算术运算  指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。例如：  　　例二：  　　1、chara[20];  　　2、int*ptr=a;  　　...  　...  　　3、ptr++;  　　在上例中，指针ptr的类型是int*,它指向的类型是int，它被初始化为指向整形变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针ptr的值加上了sizeof(int)，在32位程序中，是被加上了4。由于地址是用字节做单位的，故ptr所指向的地址由原来的变量a的地址向高地址方向增加了4个字节。  由于char类型的长度是一个字节，所以，原来ptr是指向数组a的第0号单元开始的四个字节，此时指向了数组a中从第4号单元开始的四个字节。  　　我们可以用一个指针和一个循环来遍历一个数组，看例子：　　例三：  intarray[20];  int*ptr=array;  ...  //此处略去为整型数组赋值的代码。  ...  for(i=0;i <20;i++)  {  　(*ptr)++;  　ptr++；  }　　这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1，所以每次循环都能访问数组的下一个单元。  　　再看例子：  　　例四：  　　1、chara[20];  　　2、int*ptr=a;  　　...  　　...  　　3、ptr+=5;　　在这个例子中，ptr被加上了5，编译器是这样处理的：将指针ptr的值加上5乘sizeof(int)，在32位程序中就是加上了5乘4=20。由于地址的单位是字节，故现在的ptr所指向的地址比起加5后的ptr所指向的地址来说，向高地址方向移动了20个字节。在这个例子中，没加5前的ptr指向数组a的第0号单元开始的四个字节，加5后，ptr已经指向了数组a的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。  如果上例中，ptr是被减去5，那么处理过程大同小异，只不过ptr的值是被减去5乘sizeof(int)，新的ptr指向的地址将比原来的ptr所指向的地址向低地址方向移动了20个字节。  　　总结一下，一个指针ptrold加上一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值增加了n乘sizeof(ptrold所指向的类型)个字节。就是说，ptrnew所指向的内存区将比ptrold所指向的内存区向高地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。  　　一个指针ptrold减去一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值减少了n乘sizeof(ptrold所指向的类型)个字节，就是说，ptrnew所指向的内存区将比ptrold所指向的内存区向低地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。  运算符&和*  这里&是取地址运算符，*是...书上叫做 "间接运算符 "。  　　&a的运算结果是一个指针，指针的类型是a的类型加个*，指针所指向的类型是a的类型，指针所指向的地址嘛，那就是a的地址。  　　*p的运算结果就五花八门了。总之*p的结果是p所指向的东西，这个东西有这些特点：它的类型是p指向的类型，它所占用的地址是p所指向的地址。  　　例五：  inta=12;  intb;  int*p;int**ptr;  p=&a;//&a的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a的地址。  *p=24;//*p的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，显然，*p就是变量a。  ptr=&p;//&p的结果是个指针，该指针的类型是p的类型加个*，在这里是int   **。该指针所指向的类型是p的类型，这里是int*。该指针所指向的地址就是指针p自己的地址。  *ptr=&b;//*ptr是个指针，&b的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以用&b来给*ptr赋值就是毫无问题的了。  **ptr=34;//*ptr的结果是ptr所指向的东西，在这里是一个指针，对这个指针再做一次*运算，结果就是一个int类型的变量。　　指针表达式  一个表达式的最后结果如果是一个指针，那么这个表达式就叫指针表式。  　　下面是一些指针表达式的例子：  　　例六：  inta,b;  intarray[10];  int*pa;  pa=&a;//&a是一个指针表达式。  int**ptr=&pa;//&pa也是一个指针表达式。  *ptr=&b;//*ptr和&b都是指针表达式。  pa=array;  pa++;//这也是指针表达式。例七：  char*arr[20];  char**parr=arr;//如果把arr看作指针的话，arr也是指针表达式  char*str;  str=*parr;//*parr是指针表达式  str=*(parr+1);//*(parr+1)是指针表达式  str=*(parr+2);//*(parr+2)是指针表达式　　由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。　　好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。  　　在例七中，&a不是一个左值，因为它还没有占据明确的内存。*ptr是一个左值，因为*ptr这个指针已经占据了内存，其实*ptr就是指针pa，既然pa已经在内存中有了自己的位置，那么*ptr当然也有了自己的位置。  　　数组和指针的关系  　　数组的数组名其实可以看作一个指针。看下例：  　　例八：  intarray[10]={0,1,2,3,4,5,6,7,8,9},value;  ...  ...  value=array[0];//也可写成：value=*array;  value=array[3];//也可写成：value=*(array+3);  value=array[4];//也可写成：value=*(array+4);上例中，一般而言数组名array代表数组本身，类型是int[10]，但如果把array看做指针的话，它指向数组的第0个单元，类型是int*，所指向的类型是数组单元的类型即int。因此*array等于0就一点也不奇怪了。同理，array+3是一个指向数组第3个单元的指针，所以*(array+3)等于3。其它依此类推。  　　例九：  char*str[3]={  　 "Hello,thisisasample! ",  　 "Hi,goodmorning. ",  　 "Helloworld "  };  chars[80]；  strcpy(s,str[0]);//也可写成strcpy(s,*str);  strcpy(s,str[1]);//也可写成strcpy(s,*(str+1));  strcpy(s,str[2]);//也可写成strcpy(s,*(str+2));上例中，str是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名str当作一个指针的话，它指向数组的第0号单元，它的类型是char**，它指向的类型是char*。  *str也是一个指针，它的类型是char*，它所指向的类型是char，它指向的地址是字符串 "Hello,thisisasample! "的第一个字符的地址，即 'H '的地址。   str+1也是一个指针，它指向数组的第1号单元，它的类型是char**，它指向的类型是char*。  　　*(str+1)也是一个指针，它的类型是char*，它所指向的类型是char，它指向   "Hi,goodmorning. "的第一个字符 'H '，等等。  　　下面总结一下数组的数组名的问题。声明了一个数组TYPEarray[n]，则数组名称array就有了两重含义：第一，它代表整个数组，它的类型是TYPE[n]；第二   ，它是一个指针，该指针的类型是TYPE*，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0号单元，该指针自己占有单独的内存区，注意它和数组第0号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。  　　在不同的表达式中数组名array可以扮演不同的角色。  　　在表达式sizeof(array)中，数组名array代表数组本身，故这时sizeof函数测出的是整个数组的大小。  在表达式*array中，array扮演的是指针，因此这个表达式的结果就是数组第0号单元的值。sizeof(*array)测出的是数组单元的大小。  　　表达式array+n（其中n=0，1，2，....。）中，array扮演的是指针，故array+n的结果是一个指针，它的类型是TYPE*，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。  例十intarray[10];  int(*ptr)[10];  ptr=&array;：  上例中ptr是一个指针，它的类型是int(*)[10]，他指向的类型是int[10]   ，我们用整个数组的首地址来初始化它。在语句ptr=&array中，array代表数组本身。  　　本节中提到了函数sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？答案是前者。例如：  int(*ptr)[10];  　　则在32位程序中，有：  sizeof(int(*)[10])==4  sizeof(int[10])==40  sizeof(ptr)==4实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。指针和结构类型的关系  可以声明一个指向结构类型对象的指针。  　　例十一：  structMyStruct  {  　inta;  　intb;  　intc;  }  MyStructss={20,30,40};//声明了结构对象ss，并把ss的三个成员初始化为20，30和40。  MyStruct*ptr=&ss;//声明了一个指向结构对象ss的指针。它的类型是MyStruct*,它指向的类型是MyStruct。  int*pstr=(int*)&ss;//声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同的。　　请问怎样通过指针ptr来访问ss的三个成员变量？  　　答案：  ptr-> a;  ptr-> b;  ptr-> c;  　　又请问怎样通过指针pstr来访问ss的三个成员变量？  　　答案：  *pstr；//访问了ss的成员a。  *(pstr+1);//访问了ss的成员b。  *(pstr+2)//访问了ss的成员c。  　　虽然我在我的MSVC++6.0上调式过上述代码，但是要知道，这样使用pstr来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元：  　　例十二：  intarray[3]={35,56,37};  int*pa=array;  　　通过指针pa访问数组array的三个单元的方法是：  *pa;//访问了第0号单元  *(pa+1);//访问了第1号单元  *(pa+2);//访问了第2号单元 从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。  　　所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个 "填充字节 "，这就导致各个成员之间可能会有若干个字节的空隙。  　　所以，在例十二中，即使*pstr访问到了结构对象ss的第一个成员变量a，也不能保证*(pstr+1)就一定能访问到结构成员b。因为成员a和成员b之间可能会有若干填充字节，说不定*(pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。  过指针访问结构成员的正确方法应该是象例十二中使用指针ptr的方法。  　　指针和函数的关系  　　可以把一个指针声明成为一个指向函数的指针。intfun1(char*,int);  int(*pfun1)(char*,int);  pfun1=fun1;  ....  ....  inta=(*pfun1)( "abcdefg ",7);//通过函数指针调用函数。  可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。  　　例十三：  intfun(char*);  inta;  charstr[]= "abcdefghijklmn ";  a=fun(str);  ...  ...  intfun(char*s)  {  intnum=0;  for(inti=0;i{  num+=*s;s++;  }  returnnum;}　　这个例子中的函数fun统计一个字符串中各个字符的ASCII码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把str作为实参传递给形参s后，实际是把str的值传递给了s，s所指向的地址就和str所指向的地址一致，但是str和s各自占用各自的存储空间。在函数体内对s进行自加1运算，并不意味着同时对str进行了自加1运算。指针类型转换  当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。  　　例十四：  　　1、floatf=12.3;  　　2、float*fptr=&f;  　　3、int*p;  　　　在上面的例子中，假如我们想让指针p指向实数f，应该怎么搞？是用下面的语句吗？  　　p=&f;  　　不对。因为指针p的类型是int*，它指向的类型是int。表达式&f的结果是一个指针，指针的类型是float*,它指向的类型是float。两者不一致，直接赋值的方法是不行的。至少在我的MSVC++6.0上，对指针的赋值语句要求赋值号两边的类型一致，所指向的类型也一致，其它的编译器上我没试过，大家可以试试。为了实现我们的目的，需要进行 "强制类型转换 "：  p=(int*)&f;如果有一个指针p，我们需要把它的类型和所指向的类型改为TYEP*TYPE，   那么语法格式是：  　　(TYPE*)p；  　　这样强制类型转换的结果是一个新指针，该新指针的类型是TYPE*，它指向的类型是TYPE，它指向的地址就是原指针指向的地址。而原来的指针p的一切属性都没有被修改。  　　一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，也会发生指针类型的转换。  　　例十五：voidfun(char*);  inta=125,b;  fun((char*)&a);  ...  ...  voidfun(char*s)  {  charc;  c=*(s+3);*(s+3)=*(s+0);*(s+0)=c;  c=*(s+2);*(s+2)=*(s+1);*(s+1)=c;  }  }  注意这是一个32位程序，故int类型占了四个字节，char类型占一个字节。函数fun的作用是把一个整数的四个字节的顺序来个颠倒。注意到了吗？在函数调用语句中，实参&a的结果是一个指针，它的类型是int*，它指向的类型是int。形参这个指针的类型是char*，它指向的类型是char。这样，在实参和形参的结合过程中，我们必须进行一次从int*类型到char*类型的转换。结合这个例子，我们可以这样来想象编译器进行转换的过程：编译器先构造一个临时指针char*temp，   然后执行temp=(char*)&a，最后再把temp的值传递给s。所以最后的结果是：s的类型是char*,它指向的类型是char，它指向的地址就是a的首地址。  　　我们已经知道，指针的值就是指针指向的地址，在32位程序中，指针的值其实是一个32位整数。那可不可以把一个整数当作指针的值直接赋给指针呢？就象下面的语句：unsignedinta;  TYPE*ptr;//TYPE是int，char或结构类型等等类型。  ...  ...  a=20345686;  ptr=20345686;//我们的目的是要使指针ptr指向地址20345686（十进制  ）  ptr=a;//我们的目的是要使指针ptr指向地址20345686（十进制）编译一下吧。结果发现后面两条语句全是错的。那么我们的目的就不能达到了吗？不，还有办法：  unsignedinta;  TYPE*ptr;//TYPE是int，char或结构类型等等类型。  ...  ...  a=某个数，这个数必须代表一个合法的地址；  ptr=(TYPE*)a；//呵呵，这就可以了。严格说来这里的(TYPE*)和指针类型转换中的(TYPE*)还不一样。这里的(TYPE*)的意思是把无符号整数a的值当作一个地址来看待。上面强调了a的值必须代表一个合法的地址，否则的话，在你使用ptr的时候，就会出现非法操作错误。  　　想想能不能反过来，把指针指向的地址即指针的值当作一个整数取出来。完   全可以。下面的例子演示了把一个指针的值当作一个整数取出来，然后再把这个整数当作一个地址赋给一个指针：  　　例十六：  inta=123,b;  int*ptr=&a;  char*str;  b=(int)ptr;//把指针ptr的值当作一个整数取出来。  str=(char*)b;//把这个整数的值当作一个地址赋给指针str。　　现在我们已经知道了，可以把指针的值当作一个整数取出来，也可以把一个整数值当作地址赋给一个指针。  　　指针的安全问题  看下面的例子：  　　例十七：chars= 'a ';  int*ptr;  ptr=(int*)&s;  *ptr=1298；  　　指针ptr是一个int*类型的指针，它指向的类型是int。它指向的地址就是s的首地址。在32位程序中，s占一个字节，int类型占四个字节。最后一条语句不但改变了s所占的一个字节，还把和s相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错误。  　　让我们再来看一例：  　　例十八：  　　1、chara;  　　2、int*ptr=&a;  　　...  　　...  　　3、ptr++;  　　4、*ptr=115;  　　该例子完全可以通过编译，并能执行。但是看到没有？第3句对指针ptr进行自加1运算后，ptr指向了和整形变量a相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代码。而第4句竟然往这片存储区里写入一个数据！这是严重的错误。所以在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里。在用指针访问数组的时候，也要注意不要超出数组的低端和高端界限，否则也会造成类似的错误。  　　在指针的强制类型转换：ptr1=(TYPE*)ptr2中，如果sizeof(ptr2的类型)大于sizeof(ptr1的类型)，那么在使用指针ptr1来访问ptr2所指向的存储区时是安全的。如果sizeof(ptr2的类型)小于sizeof(ptr1的类型)，那么在使用指针ptr1来访问ptr2所指向的存储区时是不安全的。至于为什么，读者结合例十七来想一想，应该会明白的。